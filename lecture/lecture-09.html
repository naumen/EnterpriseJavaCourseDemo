<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Многопоточность и JAVA</title>

        <meta name="description" content="Многопоточность и JAVA">
        <meta name="author" content="NAUMEN, Павел Зыков">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/white.css" id="theme">

        <link rel="stylesheet" href="css/hljs/vs.css" id="highlight-theme">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->

        <style>
.reveal .slide-number {
    font-size:22pt;
    color:black;
}

.reveal pre {
    background: none;
    border: none;
    box-shadow: none;    
}

.reveal pre code{
    color: black;
    background: none;
    box-shadow: none;
    max-height: none;
    overflow: hidden;
}

.reveal pre code.small{
    font-size: 8pt;
    line-height:normal;
}
.reveal pre code.medium{
    font-size: 10pt;
    line-height:normal;
}

.reveal section img {
    border: none;
    box-shadow: none;
    max-width:70%
}

.reveal .footer {
    font-size:22pt;
    color:black;
    text-align: center;
    position: absolute; 
    width:100%;
    bottom: 0.5em;
}

.reveal .cartoon{
    position: absolute;
    right: 0;
    bottom:0;
}

.reveal .rubber_stamp {
  font-family: 'Vollkorn', serif;
  font-size: 39px;
  line-height: 45px;
  text-transform: uppercase;
  font-weight: bold;
  color: red;
  border: 7px solid red;
  float: left;
  padding: 10px 7px;
  border-radius: 10px;
  
  opacity: 0.8;
  -webkit-transform: rotate(-10deg);
  -o-transform: rotate(-10deg);
  -moz-transform: rotate(-10deg);
  -ms-transform: rotate(-10deg);
  position:absolute;
  bottom:20%;
  right:1%;
}
.reveal .rubber_stamp::after {
  position: absolute;
  content: " ";
  width: 100%;
  height: auto;
  min-height: 100%;
  top: -10px;
  left: -10px;
  padding: 10px;
  background: url(img/noise.png) repeat;
}
.reveal  .nau{
            color: orangered;
            font-weight: bold;
            font-family: 'Franklin Gothic Medium', 'Arial Narrow', Arial, sans-serif;
        }
        </style>
    </head>

    <body>

        <div class="reveal">
            <div class="footer">
                <span class="nau">NAUMEN</span> Павел Зыков
            </div>
            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Многопоточность</h1>
                    <h2>и</h2>
                    <h1>JAVA</h1>
                </section>
                <section>
                    <h2>Что такое процесс?</h2>
                    <p><b>Процесс</b> — экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы (например, процессорное время и память). Каждый процесс выполняется в отдельном адресном пространстве: один процесс не может получить доступ к переменным и структурам данных другого. Если процесс хочет получить доступ к чужим ресурсам, необходимо использовать межпроцессное взаимодействие.</p>
                </section>
                <section>
                    <h2>Что такое поток?</h2>    
                    <p><b>Поток</b> использует то же самое пространства стека, что и процесс, а множество потоков совместно используют данные своих состояний. Каждый поток может работать (читать и писать) с одной и той же областью памяти, в отличие от процессов, которые не могут просто так получить доступ к памяти другого процесса. У каждого потока есть собственные регистры и собственный стек, но другие потоки могут их использовать.</p>
                    <p></p>
                </section>
                <section>
                    <h2>Процессы и потоки</h2>
                    <img src="img/processes_and_threads.png">
                </section>
                <section>
                    <h2>Как представлен поток в JAVA?</h2>
                    <ul>
                        <li><b>Поток</b> — объект у класса которого есть методы run() и  start()</li>
                        <li>После вызова метода start(), <i>через какое-то время</i> будет вызван run()</li>
                        <li>Метод run() будет выполнен в своем стеке.</li>
                    </ul>
                </section>
                <section>
                    <h2>Роль операционной системы</h2>
                    <img src="img/processes_and_threads.png">
                </section>
                <section>
                    <h2>Роль операционной системы</h2>
                    <ul>
                        <li>Создает потоки</li>
                        <li>Переключает потоки</li>
                        <li>API для уведомления потока</li>
                    </ul>
                </section>
                <section>
                    <h2>Запуск потоков</h2>
                    <img src="img/threads_timeline.png">
                </section>
                <section>
                    <h2>Порядок не определен!</h2>
                    <img src="img/threads_timeline2.png">
                </section>
                <section>
                    <h2>Java Concurrency</h2>
                    <p>В Java есть два пути разрабоки многопоточных приложений:</p>
                    <ul>
                        <li>Сделать всё руками: Thread, Runable, wait/notify, synchronized</li>
                        <li>Использовать высокоуровневое API: java.utils.concurrent</li>
                    </ul>
                </section>
                <section>
                    <h2>Как создать поток?</h2>
                    <p>Реализовать интерфейс Runnable</p>
                    <pre style="width:auto;"><code data-trim class="java">
// Создание потока
Thread t = new Thread(new Runnable() {
    public void run() {
        System.out.println("Hello world!");
    }
});
// Запуск потока
t.start();
                    </code></pre>
                </section>
                <section>
                    <h2>Как создать поток?</h2>
                    <p>Наследовать класс Thread</p>
                    <pre style="width:auto;"><code data-trim class="java">
// Создание потока
Thread t = new Thread() {
    public void run() {
        System.out.println("Hello world!");
    }
};
// Запуск потока
t.start();
                    </code></pre>
                </section>
                <section>
                    <h2>Thread vs Runnable</h2>
                    <ul>
                        <p><b>Runnable</b></p>
                        <ul>
                        <li>Можно наследовать класс отличный от Thread</li>
                        <li>Нужно передавать в конструктор Thread</li>
                        </ul>
                        <p><b>Thread</b></p>
                        <ul>
                        <li>Содержит методы упраления потоком</li>
                        </ul>
                        <p><b>Thread thread = Thread.currentThread()</b></p>
                        <ul>
                        <li>Объект текущего потока можно получить из любого места кода</li>
                        </ul>
                    </ul>
                    
                </section>
                <section>
                    <h2>Класс Thread</h2>
                    <p>Некоторые методы:</p>
                    <pre style="width:auto;"><code data-trim class="java">
long getId()
String getName()
void setName(String name)
int getPriority()
void setPriority(int priority)
static void sleep(long ms)
void interrupt()
static boolean interrupted()
void join()
static void yield()
                    </code></pre>
                    <div class="cartoon fragment"><img src="img/threads_and_kitten.png"/></div>
                </section>
                <section>
                    <h2>Прерывания</h2>
                    <pre style="width:auto;"><code data-trim class="java">
thread.interrupt(); //прервать поток thread
                    </code></pre>
                </section>
                                <section>
                    <h2>Прерывания</h2>
                    <pre style="width:auto;"><code data-trim class="java">
try{
    Thread.sleep(5000);
}
catch(InterruptedException e){ //нас прервали

    return;
}
                    </code></pre>
                </section>
                <section>
                    <h2>Прерывания</h2>
                    <pre style="width:auto;"><code data-trim class="java">
for(int i = 0; i< inputs[i];i++){
    heavyTask(inputs[i]);
    if(Thread.interrupted()){ //нас прервали
        return;
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Состояния потоков</h2>
                    <img src="img/thread_states.png"/>
                </section>
                <section>
                    <h2>Классические задачи многопоточного программирования</h2>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                </section>
                <section>
                    <h2>Задача доступа к общему ресурсу</h2>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                    <ul>
                        <li>Несколько потоков обращаются к общему ресурсу</li>
                    </ul>
                    <img src="img/shared_resource.png"/>
                </section>
                <section>
                    <h2>Счетчик</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class UnsafeCounter implements Counter{
    private int counter = 0;

    @Override
    public int get(){
        return counter;
    }

    @Override
    public void increment(){
        counter++;
    }

    @Override
    public void reset(){
        counter = 0;
    }

}
                    </code></pre>
                </section>
                <section>
                    <pre style="width:auto;"><code data-trim class="java small">
public class ExperimentRunner{
    private int threadsNumber;
    private int experimentsNumber;
    private int repeatsNumber;

    public ExperimentRunner(int threadsNumber, int experimentsNumber, int repeatsNumber){
        this.threadsNumber = threadsNumber;
        this.experimentsNumber = experimentsNumber;
        this.repeatsNumber = repeatsNumber;
    }

    public void runExperiments(Counter counter){
        long totalTime = 0;
        System.out.format("Counter '%s':\n", counter.getClass().getName());
        for (int i = 0; i < experimentsNumber; i++){
            long startTime = System.currentTimeMillis();
            runExperiment(counter);
            long elapsed = (System.currentTimeMillis() - startTime);
            totalTime += elapsed;
            System.out.format(" Experiment [%d/%d]:\tvalue = %d time = %d ms\n", i + 1, experimentsNumber,
                    counter.get(), elapsed);
            counter.reset();
        }
        System.out.format(" Average time:\t%d ms\n", totalTime / experimentsNumber);
    }

    private void runExperiment(Counter counter){
        Runnable experiment = () -> {
            for (int i = 0; i < (repeatsNumber / threadsNumber); i++){
                counter.increment();
            }
        };

        List&lt;Thread&gt; threads = Stream.generate(() -> new Thread(experiment)).limit(threadsNumber)
                .collect(Collectors.toList());

        threads.forEach(t -> t.start());
        threads.forEach(t -> {
            try{
                t.join();
            }
            catch (InterruptedException e){
                e.printStackTrace();
            }
        });
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Запуск эксперимента</h2>
                    <pre style="width:auto;"><code data-trim class="java">
private void runExperiment(Counter counter){
    Runnable experiment = () -> {
        for (int i = 0; i < (repeatsNumber / threadsNumber); i++){
            counter.increment();
        }
    };

    List&lt;Thread&gt; threads = Stream.generate(() -> new Thread(experiment))
            .limit(threadsNumber).collect(Collectors.toList());

    threads.forEach(t -> t.start());
    threads.forEach(t -> {
        try{
            t.join();
        }
        catch (InterruptedException e){
            e.printStackTrace();
        }
    });
}
                    </code></pre>
                </section>

                <section>
                    <h2>Счетчик</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public static void main(String[] args)
{
    Counter counter = new UnsafeCounter();
    ExperimentRunner runner = new ExperimentRunner(4, 5, 100_000_000);
    runner.runExperiments(counter));   
}
                    </code></pre>
                </section>

                <section>
                    <h2>Счетчик</h2>
                    <pre>
Counter 'ru.naumen.counter.impls.UnsafeCounter':
 Experiment [1/5]:  value = 74618414 time = 25 ms
 Experiment [2/5]:  value = 66158308 time = 3 ms
 Experiment [3/5]:  value = 54063137 time = 3 ms
 Experiment [4/5]:  value = 76346929 time = 4 ms
 Experiment [5/5]:  value = 44644001 time = 4 ms
 Average time:  7 ms
                     </pre>
                     <p>Быстро, но неправильно.</p>
                     <div class="cartoon"><img src="img/boo.png"/></div>
                </section>
                 <section>
                    <h2>Инкремент  не атомарен</h2>
                    <img src="img/concurrent_increment.png"/>
                </section>
                <section>
                    <h2>Базовые термины</h2>
                    <ul>
                        <li>Critical Section</li>
                        <li>Semaphore</li>
                        <li>Mutex</li>
                        <li>Monitor</li>
                        <li>Lock</li>
                    </ul>
                </section>
                <section>
                    <h2>Critical Section</h2>
                    <p>Участок исполняемого кода программы, в котором производится доступ к общему ресурсу (данным или устройству), который не должен быть одновременно использован более чем одним потоком исполнения</p>
                </section>
                <section>
                    <h2>Semaphore</h2>
                    <p>Объект, ограничивающий количество потоков, которые могут войти в заданный участок кода. (Э. Дейкстра)</p>
                    <p>Возможные операции над семафором:</p>
                    <pre>
init(n): //Инициализация семафора (задать начальное значение счётчика)
    счётчик := n

enter()://Захват семафора (ждать пока счётчик станет больше 0, после этого уменьшить счётчик на единицу)
    счётчик := счётчик - 1

leave()://Освобождение семафора (увеличить счётчик на единицу)
    счётчик := счётчик + 1
                    </pre>
                </section>
                <section>
                    <h2>Mutex</h2>
                    <p>это простейшие двоичные семафоры, которые могут находиться в одном из двух состояний — отмеченном или неотмеченном.</p>
                </section>
                <section>
                    <h2>Monitor</h2>
                    <p>Высокоуровневая кострукция, которая состоит из mutex-а и массива ожидающих очереди потоков.</p>
                    <p>У монитора должен быть механизм остановки потока и сигнализации о доступности продолжения работы.</p>
                </section>
                <section>
                    <h2>Lock</h2>
                    <p>Это механизм синхронизации, позволяющий обеспечить исключительный доступ к разделяемому ресурсу между несколькими потоками</p>
                    <p><b>Мягкая блокировка</b> — каждый поток пытается получить блокировку перед доступом к соответсвующему разделяемому ресурсу.</p>
                    <p><b>Обязательная блокировка</b> — попытка несанкционированного доступа к заблокированному ресурсу будет прервана, через создание исключения.</p>
                </section>
                <section>
                    <h2>Ключевое слово synchronized</h2>
                    <p>Синхронизация методов на текущем объекте</p>
                    <pre style="width:auto;"><code data-trim class="java">
public class SynchronizedCounter implements Counter{
    private int counter = 0;

    @Override
    public synchronized int get(){
        return counter;
    }

    @Override
    public synchronized void increment(){
        counter++;
    }

    @Override
    public synchronized void reset(){
        counter = 0;
    }
}
                    </code></pre>
                    <div class="rubber_stamp fragment">AVG. TIME = 6076 ms</div>
                </section>
                <section>
                    <h2>Ключевое слово synchronized</h2>
                    <p>Синхронизация блока на произвольном объекте</p>
                    <pre style="width:auto;"><code data-trim class="java">
Object lock = new Object();                    
synchronized(lock){
	//do something
}
                    </code></pre>
                </section>
                <section>
                    <h2>Ключевое слово synchronized</h2>
                    <p>Синхронизация статического метода</p>
                    <pre style="width:auto;"><code data-trim class="java">
public class TestStaticSync{
    public static synchronized void doSomething(){
        //do something
    }
}
                    </code></pre>
                    <p>Синхронизация происходит на объекте TestStaticSync.class</p>
                </section>
                <section>
                    <h2>Singleton</h2>
                    <ul>
                        <li>Потокобезопасный
                            <ul>
                                <li>Все получат один и тот же синглетон</li>
                                <li>Корректно проиницилизирован</li>
                            </ul>
                        </li>
                        <li>Ленивый</li>
                        <li>Эффективный</li>
                    </ul>
                </section>
                <section>
                    <h2>Synchronized Accessor</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class Singleton{
    private static Singleton instance;
    
    public static synchronized Singleton getInstance(){
        if (instance == null){
            instance = new Singleton();
        }
        return instance;
    }
}
                    </code></pre>
                    <div class="cartoon fragment"><img src="img/boo.png"/></div>
                </section>
                <section>
                    <h2>Double Checked Locking</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class Singleton {
        private static Singleton instance;
    
        public static Singleton getInstance() {
        Singleton localInstance = instance;
        if (localInstance == null) {
            synchronized (Singleton.class) {
                localInstance = instance;
                if (localInstance == null) {
                    instance = localInstance = new Singleton();
                }
            }
        }
        return localInstance;
    }
}
                    </code></pre>
                    <div class="cartoon fragment"><img src="img/boo.png"/></div>
                </section>
                <section>
                    <h2>volatile</h2>
                    <ul>
                    <li>Потоки могут кешировать переменные</li>
                    <li>Значения в кешах разных потоков могут не совпадать</li>
                    </ul>
                    <pre style="width:auto;"><code data-trim class="java">
volatile int i = 0; // означает, то что переменную i 
                    //нужно всегда брать из общей памяти
                    </code></pre>
                </section>
                                <section>
                    <h2>Double Checked Locking &amp; volatile</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class Singleton {
        private static volatile Singleton instance;
    
        public static Singleton getInstance() {
        Singleton localInstance = instance;
        if (localInstance == null) {
            synchronized (Singleton.class) {
                localInstance = instance;
                if (localInstance == null) {
                    instance = localInstance = new Singleton();
                }
            }
        }
        return localInstance;
    }
}
                    </code></pre>
                    <div class="cartoon fragment"><img src="img/thumbs_up.png"/></div>
                </section>
                <section>
                    <h2>Очередь заданий</h2>
                    <img src="img/producer-consumer-model.png"/>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                </section>
                <section>
                    <h2>wait()/notify()/notifyAll()</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class JobQueue{
 List&lt;Runnable&gt; jobs = new ArrayList&lt;&gt;();

 public synchronized void put(Runnable job){
  jobs.add(job);
  this.notifyAll();
 }

 public synchronized Runnable getJob(){
  while (jobs.size()==0){
   this.wait();
  }
  return jobs.remove(0);
 }
}
                    </code></pre>
                </section>
                <section>
                    <h2>interface Lock</h2>
                    <pre style="width:auto;"><code data-trim class="java medium">
Lock l = ...;
l.lock();
try
{
    //действия над ресурсом, защищенным данной блокировкой
}
finally
{
    l.unlock() //гарантия того, что блокировка будет отпущена
}
                    </code></pre>
                </section>
                <section>
                    <h2>interface Lock</h2>
                    <ul>
                        <p>Широко используются две основные реализации Lock:</p>
                        <li>ReentrantLock</li>
                        <li>ReadWriteLock - имеет разные механизмы блокировки на чтение и запись, позволяя уменьшить накладные расходы</li>
                    </ul>
                </section>
                <section>
                    <h2>ReentrantLock</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class ReentrantLockCounter implements Counter{
    ReentrantLock lock;
    private int counter = 0;

    public ReentrantLockCounter(boolean fair){
        lock = new ReentrantLock(fair);
    }

    ...

    @Override
    public void increment(){
        lock.lock();
        try{
            counter++;
        }
        finally{
            lock.unlock();
        }
    }
    ...
}
                    </code></pre>
                    <div class="rubber_stamp fragment">AVG. TIME = 3654 ms</div>
                </section>
                <section>
                    <h2>interface Condition</h2>
                    <ul>
                        <li>Методы:</li>
                        <pre style="width:auto;"><code data-trim class="java">
void await() throws InterruptedException;
void signal();
void signalAll();
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>interface Condition</h2>
                    <ul>
                        <li>Создание:</li>
                        <pre style="width:auto;"><code data-trim class="java">
Lock lock = new ReentrantLock();
Condition blockingPoolA = lock.newCondition();
Condition blockingPoolB = lock.newCondition();
Condition blockingPoolC = lock.newCondition();
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>Condition: применение</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class JobQueueWithLock{
    List&lt;Runnable&gt; jobs = new ArrayList&lt;&gt;();
    Lock lock = new ReentrantLock();
    Condition cond = lock.newCondition();
    public void put(Runnable job){
        lock.lock();
        try {
            jobs.add(job);
            cond.signalAll();
        } 
        finally {lock.unlock();}
    }
    public Runnable getJob(){
        lock.lock();
        try{
            while (jobs.size() == 0)
                cond.await();
            return jobs.remove(0);
        }
        finally{
            lock.unlock();
        }
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>Задача о читателях и писателях</h2>
                    <ul>
                        <li>Читать могут много потоков одновременно</li>
                        <li>Писать может только один поток</li>
                        <li>Читать во время записи нельзя</li>
                    </ul>
                    <img src="img/readers_and_writers.png"/>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                </section>
                <section>
                    <h2>ReentrantReadWriteLock</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class RWLockCounter implements Counter{
    ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
    private int counter = 0;

    public RWLockCounter(boolean fair){
        lock = new ReentrantReadWriteLock(fair);
    }

    ...

    @Override
    public void increment(){
        lock.writeLock().lock();
        counter++;
        lock.writeLock().unlock();
    }

    ...
}
                    </code></pre>
                    <div class="rubber_stamp fragment">AVG. TIME = 3544 ms</div>
                </section>
                <section>
                    <h2>StampedLock</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class StampedLockCounter implements Counter
{
    StampedLock lock;
    private int counter = 0;

    public StampedLockCounter()
    {
        lock = new StampedLock();
    }

    ...

    @Override
    public void increment()
    {
        long stamp = lock.writeLock();
        counter++;
        lock.unlockWrite(stamp);
    }

    ...
}
                    </code></pre>
                    <div class="rubber_stamp fragment">AVG. TIME = 3164 ms</div>
                </section>
                <section>
                    <h2>Атомарные операции</h2>
                    <p>Атомарные операции выполняются целиком, их выполнение не может быть прервано планировщиком потоков.</p>
                    <p>Аппаратная поддержка — compare-and-swap</p>
                </section>
                <section>
                    <h2>Атомарные операции</h2>
                    <p>Классы для выполнения атомарных операций находятся в java.util.concurrent.atomic:</p>
                    <ul>
                        <li>AtomicInteger</li>
                        <li>AtomicLong</li>
                        <li>AtomicDouble</li>
                        <li>AtomicReference</li>
                    </ul>
                </section>
                <section>
                    <h2>CAS</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class SimulatedCAS 
{
    private int value;

    public synchronized int getValue() { return value; }

    public synchronized int compareAndSwap(int expectedValue, int newValue) 
    {
        int oldValue = value;
        if (value == expectedValue)
        {
            value = newValue;
        }
        return oldValue;
    }
}
                </code></pre>
                </section>
                <section>
                    <h2>AtomicInteger</h2>
                    <pre style="width:auto;"><code data-trim class="java">
public class AtomicCounter implements Counter
{
    private AtomicInteger counter = new AtomicInteger(0);

    @Override
    public int get()
    {
        return counter.intValue();
    }

    @Override
    public void increment()
    {
        counter.incrementAndGet();
    }

    @Override
    public void reset()
    {
        counter.set(0);
    }
}
                    </code></pre>
                    <div class="rubber_stamp fragment">AVG. TIME = 1701 ms</div>
                </section>
                <section>
                    <h2>Производительность</h2>
                    <table>
                        <thead>
                            <tr>
                                <td>Метод синхронизации</td>
                                <td>Среднее время выполнения (мс)</td>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>AtomicInteger</td>
                                <td>1701</td>
                            </tr>
                            <tr>
                                <td>StampedLock</td>
                                <td>3164</td>
                            </tr>
                            <tr>
                                <td>ReentrantReadWriteLock</td>
                                <td>3544</td>
                            </tr>
                            <tr>
                                <td>ReentrantLock</td>
                                <td>3654</td>
                            </tr>
                            <tr>
                                <td>synchronized</td>
                                <td>6076</td>
                            </tr>
                        </tbody>
                    </table>
                </section>
                <section>
                    <h2>ThreadLocal</h2>
                    <ul>
                        <li>Позволяет хранить данные изолированно от других потоков</li>
                    </ul>
                    <pre style="width:auto;"><code data-trim class="java">
public class ShoppingCard{
    ThreadLocal&lt;ArrayList&lt;Item>> myThreadLocal = ThreadLocal.withInitial(ArrayList::new);

    public void add(Item item){
        myThreadLocal.get().add(item);
    }

    public String getReceipt(){
        StringBuilder sb = new StringBuilder();
        myThreadLocal.get().forEach(item -> sb.append(String.format("%s - %d$\n", item.getName(), item.getPrice())));
        return sb.toString();
    }

    public void remove(Item item){
        myThreadLocal.get().add(item);
    }
}
                    </code></pre>
                </section>
                <section>
                    <h2>ThreadLocal</h2>
                    <pre style="width:auto;"><code data-trim class="java">
ShoppingCard shoppingCard = new ShoppingCard();

Thread customer1 = new Thread(() -> {
    shoppingCard.add(new Item("Banana", 1));
    shoppingCard.add(new Item("Beer", 5));
    System.out.format("Receipt for customer1 :\n%s\n", shoppingCard.getReceipt());
});

Thread customer2 = new Thread(() -> {
    shoppingCard.add(new Item("Cola", 2));
    shoppingCard.add(new Item("Bread", 1));
    System.out.format("Receipt for customer2 :\n%s\n", shoppingCard.getReceipt());
});

customer1.start();
customer2.start();
customer1.join();
customer2.join();
                    </code></pre>
                </section>
                <section>
                    <h2>Потокобезопасные структуры данных</h2>
                    <ul>
                        <li>CopyOnWriteArrayList</li>
                        <li>CopyOnWriteArraySet</li>
                        <li>ConcurrentHashMap</li>
                        <li>ConcurrentLinkedDeque</li>
                        <li>ConcurrentLinkedQueue</li>
                        <li>ConcurrentSkipListMap</li>
                        <li>ConcurrentSkipListSet</li>
                    </ul>
                </section>
                 <section>
                    <h2>Copy-on-write</h2>
                    <ul>
                        <li>CopyOnWriteArrayList и CopyOnWriteArraySet основаны на массиве, копируемом при операции записи</li>
                        <li>Хороши когда 90% записи</li>
                        <li>При частой записи большая коллекция может убить производительность</li>
                        <li>Сортировки нет</li>
                        <li>Итераторы не поддерживают операций модификации</li>
                    </ul>
                </section>
                <section>
                    <h2>Производитель-потребитель</h2>
                    <ul>
                        <li>Один поток производит данные, второй их потребляет</li>
                        <li>Несколько потоков производят данные и несколько их потребляют</li>
                        <li>Данные могут храниться в очереди (не)ограниченного объема</li>
                    </ul>
                    <img src="img/producer_consumer.png"/>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                </section>
                <section>
                    <h2>Задания-работники</h2>
                    <ul>
                        <li>Поток-клиент ждет выполнения задания потоком-сервером</li>
                    </ul>
                    <img src="img/task_and_workers.png"/>
                    <div class="cartoon"><img src="img/problem.png"/></div>
                </section>
                <section>
                    <h2>Блокирующие очереди</h2>
                    <ul>
                        <li>ArrayBlockingQueue</li>
                        <li>LinkedBlockingDeque</li>
                        <li>LinkedBlockingQueue</li>
                        <li>PriorityBlockingQueue</li>
                        <li>DelayQueue              элементы с задержкой</li>
                        <li>LinkedTransferQueue     универсальная очередь</li>
                        <li>SynchronousQueue        ёмкость 0</li>
                    </ul>
                </section>
                <section>
                    <h2>Пул потоков</h2>
                    <ul>
                        <li>Переиспользование потоков</li>
                        <li>Ограниченное число потоков</li>
                        <li>Очередь заданий</li>
                    </ul>
                </section>
                <section>
                    <h2>ExecutorService Framework</h2>
                    <p><b>Цель применения:</b> отделить работу, выполняемую внутри потока, от логики создания потоков.</p>
                    <p>Создание:</p>
                    <pre style="width:auto;"><code data-trim class="java">
Executors.newCachedThreadPool();        //Создаёт новые потоки при необходимости,
                                        //повторно использует освободившиеся потоки

Executors.newFixedThreadPool(12);       //С ограничением количества потоков

Executors.newSingleThreadExecutor();    //Ровно один поток

Executors.newScheduledThreadPool();     //Можно настроить задержку запуска / повторный запуск
                    </code></pre>
                </section>
                <section>
                <h2>Clients &amp; Workers</h2>
                <pre style="width:auto;"><code data-trim class="java">
ExecutorService workers = Executors.newFixedThreadPool(5);
ExecutorService clients = Executors.newFixedThreadPool(10);

for (int i = 3; i < 20; i++){
    final int idx = i;
    Callable&lt;Long> task = (i % 2 == 0)? (()->calculateFibonacci(idx)):
                                        (()->calculateFactorial(idx));
    Future&lt;Long> future = workers.submit(task);

    clients.execute(() -> {
        try{
            Long result = future.get();
            System.out.format("%s for %d = %d\n", 
                               idx % 2 == 0 ? "Fibonacci" : "Factorial",
                               idx, result);
        } 
        catch (InterruptedException | ExecutionException e){
            e.printStackTrace();
        }
    });
}
workers.shutdown();
clients.shutdown();
                    </code></pre>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <ul>
                        <li><b>ForkJoinPool</b></li>
                        <ul>
                            <li>… implements ExecutorService</li>
                            <li>т.е. туда можно засылать и обычные Runnable, Callable</li>
                        </ul>
                        <li><b>ForkJoinTask&lt;V></b></li>
                        <ul>
                            <li> RecursiveAction</li>
                            <li> RecursiveTask&lt;V></li>
                        </ul>
                    </ul>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <ul>
                        <li>Подход FJP - Work stealing</li>
                        <ul>
                            <li>У каждого потока своя очередь</li>
                            <li>С головой очереди может работать только владелец</li>
                            <li>Свободные потоки крадут задачи у перегруженных(из хвоста)</li>
                        </ul>
                    </ul>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <p>Пример RecursiveTask</p>
                    <pre style="width:auto;"><code data-trim class="java medium">
private static class StandardTask extends RecursiveTask&lt;Long>{
    private final Problem problem;
    private final int l;
    private final int r;
    public StandardTask(Problem p, int l, int r) {
        this.problem = p;
        this.l = l;
        this.r = r;
    }
    @Override
    protected Long compute() {
        if (r - l <= THRESHOLD){
            return problem.solve(l, r);
        }
        int mid = (l + r) >>> 1;
        ForkJoinTask&lt;Long> t1 = new StandardTask(problem, l, mid);
        ForkJoinTask&lt;Long> t2 = new StandardTask(problem, mid, r);
        t1.fork(); 
        t2.fork(); 
        long res = 0;
        res += t2.join(); 
        res += t1.join(); 
        return res;
    }
 }
                     </code></pre>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <p>Пример RecursiveTask</p>
                    <pre style="width:auto;"><code data-trim class="java">
ForkJoinTask&lt;Long> t1 = new StandardTask(problem, l, mid);
ForkJoinTask&lt;Long> t2 = new StandardTask(problem, mid, r);
t1.fork(); 
t2.fork(); 
long res = 0;
res += t2.join(); 
res += t1.join(); 
return res;
                     </code></pre>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <ul>
                        <li>fork():</li>
                        <ul>
                            <li>Кладёт задачу в очередь, и возвращается</li>
                            <li>Кто-нибудь другой может эту задачу подхватить</li>
                        </ul>
                        <li>join():</li>
                        <ul>
                            <li>Блокируется, пока задача не закончится</li>
                            <li>Но поток терять на этом нельзя!</li>
                            <li>FJP может дать ему что-нибудь повыполнять</li>
                        </ul>
                    </ul>
                </section>
                <section>
                    <h2>Fork/Join API</h2>
                    <img src="img/work_steal.png">>
                </section>
                <section>
                    <h2>Parallel Stream</h2>
                    <ul>
                        <li>Использует FJP</li>
                        <li>BaseStream.parallel</li>
                        <li>Collection.parallelStream</li>
                        <pre style="width:auto;"><code data-trim class="java">
double average = persons
    .parallelStream()
    .filter(p -> p.getGender() == Person.Sex.MALE)
    .mapToInt(Person::getAge)
    .average()
    .getAsDouble();
                        </code></pre>
                    </ul>

                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Удобный способ написания асинхронного кода</li>
                        <li>Создание:</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;Integer> answer = CompletableFuture.completedFuture(42);

CompletableFuture&lt;Integer> answer =  CompletableFuture.supplyAsync(() -> someOperation());

CompletableFuture&lt;Integer> answer =  CompletableFuture.supplyAsync(() -> someOperation(),
                                                                                executorService);
                        </code></pre>
                        <li class="fragment">Получение результата</li>
                        <pre style="width:auto;"><code data-trim class="java fragment">
                            Integer result = answer.get(); //блокирует
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Обработка результатов</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;Integer> answer =  CompletableFuture.supplyAsync(() -> someOperation());
answer.thenAccept(a -> System.out.format("Answer: %d", a));
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Цепочка обработки</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;Integer> wordsCount =  CompletableFuture.supplyAsync(() -> getText())
                                                         .thenApply(text -> text.split(" "))
                                                         .thenApply(words -> words.length);
System.out.format("Words count: %d", wordsCount.get());
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Обработка результатов нескольких CompletableFuture</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;String> text1 =  CompletableFuture.supplyAsync(() -> getText(1));
CompletableFuture&lt;String> text2 =  CompletableFuture.supplyAsync(() -> getText(1));
CompletableFuture&lt;Integer> both = text1.
                thenCombine(text2, (String textOne, String textTwo) ->
                        textOne.length() + textTwo.length()
                );
both.thenAccept(length -> System.out.format("Total length: %d", length));
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Ожидание результатов нескольких CompletableFuture</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;String> text1 =  CompletableFuture.supplyAsync(() -> getText(1));
CompletableFuture&lt;String> text2 =  CompletableFuture.supplyAsync(() -> getText(2));
CompletableFuture&lt;String> text3 =  CompletableFuture.supplyAsync(() -> getText(3));
CompletableFuture&lt;String> text4 =  CompletableFuture.supplyAsync(() -> getText(4));
CompletableFuture&lt;Void> allCompleted = CompletableFuture.allOf(text1, text2, text3, text4);
allCompleted.thenRun(() -> {
    try {
        System.out.format("Loaded: %d", text1.get());
        System.out.format("Loaded: %d", text2.get());
        System.out.format("Loaded: %d", text3.get());
        System.out.format("Loaded: %d", text4.get());
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
});
                );
                        </code></pre>
                    </ul>
                </section>
                <section>
                    <h2>CompletableFuture</h2>
                    <ul>
                        <li>Обработка ошибок</li>
                        <pre style="width:auto;"><code data-trim class="java">
CompletableFuture&lt;String> text1 =  CompletableFuture.supplyAsync(() -> getText(1));
CompletableFuture&lt;String> recovered = text1.handle((result, throwable) -> {
                    if (throwable != null) {
                        return "Not text here! Exception: " + throwable;
                    } else {
                        return result.toUpperCase();
                    }
                });

CompletableFuture&lt;String> text2 =  CompletableFuture.supplyAsync(() -> getText(2));
CompletableFuture&lt;String> recovered = text1.exceptionally(throwable -> "Sorry, try again later");
                        </code></pre>
                    </ul>
                </section>                
                <section>
                        <h1>Вопросы?</h1>
                </section>
            </div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>

            // Full list of configuration options available at:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                slideNumber: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // Optional reveal.js plugins
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true }
                ]
            });

        </script>

    </body>
</html>